@page "/admin/grades/import"
@rendermode InteractiveServer
@attribute [Authorize(Roles = "Admin,Lecturer")]
@using System.IO
@using System.Text
@using System.Linq
@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.EntityFrameworkCore
@using Microsoft.JSInterop
@using OfficeOpenXml
@using FinalAssignemnt_APDP.Data
@using FinalAssignemnt_APDP.Constants
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject FinalAssignemnt_APDP.Services.ToastQueue Toasts
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IWebHostEnvironment WebHostEnvironment
@inject FinalAssignemnt_APDP.Services.FileUploadService FileUploadService

<PageTitle>Import Grades</PageTitle>
<div class="container py-4">
    <a class="btn btn-link px-0" href="@AppRoutes.AdminGrades"><i class="bi bi-arrow-left"></i> Back to grade list</a>
    <div class="row g-4 mt-3">
        <div class="col-lg-4">
            <div class="overflow-hidden rounded-xl bg-white shadow-sm h-100">
                <div class="p-6">
                    <h5 class="fw-bold">Template</h5>
                    <p class="text-muted">Use CSV or Excel file with the following columns:</p>
                    <code class="d-block bg-slate-50 p-2 rounded small">StudentId,CourseId,Midterm,Final,Note</code>
                    <p class="text-muted mt-3 small">Download current data as reference:</p>
                    <button class="inline-flex items-center justify-center gap-2 rounded-2xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-700 shadow w-full" @onclick="DownloadExport"><i class="bi bi-download"></i> Download CSV</button>
                </div>
            </div>
        </div>
        <div class="col-lg-8">
            <div class="overflow-hidden rounded-xl bg-white shadow-sm h-100">
                <div class="p-6">
                    <h5 class="fw-bold">Upload</h5>
                    <p class="text-muted">Existing rows (Student + Course) will be updated, new rows will be created.</p>
                    <InputFile OnChange="OnFileChange" accept=".csv,.xlsx" class="form-control" />
                    <div class="form-text">
                        <strong>Supported formats:</strong> CSV (.csv) or Excel (.xlsx)<br />
                        <strong>Max size:</strong> CSV: 1 MB | Excel: 5 MB
                    </div>
                </div>
                <div class="card-footer bg-white text-end">
                    <button class="btn btn-primary" @onclick="ProcessFile" disabled="@(!canProcess || isProcessing)">
                        <span class="spinner-border spinner-border-sm me-2" role="status" hidden="@(!isProcessing)"></span>
                        Import
                    </button>
                </div>
            </div>
        </div>
    </div>

            @if (results.Any())
            {
                var inserted = results.Count(r => r.Status == ImportStatus.Inserted);
                var updated = results.Count(r => r.Status == ImportStatus.Updated);
                var failed = results.Count(r => r.Status == ImportStatus.Failed);

                <div class="mt-4 overflow-hidden rounded-xl bg-white shadow-sm p-6">
                    @if (failed == 0 && (inserted + updated) > 0)
                    {
                        <div class="inline-flex items-center gap-3 text-slate-700">
                            <i class="bi bi-check-circle-fill text-emerald-500 text-2xl"></i>
                            <div>
                                <div class="text-lg font-semibold">Import successful</div>
                                <div class="text-sm text-slate-500">@inserted rows inserted, @updated rows updated.</div>
                            </div>
                        </div>
                    }
                    else if ((inserted + updated) > 0)
                    {
                        <div class="inline-flex items-start gap-3">
                            <i class="bi bi-exclamation-triangle-fill text-amber-500 text-2xl"></i>
                            <div>
                                <div class="text-lg font-semibold">Import completed with some issues</div>
                                <div class="text-sm text-slate-500">@inserted inserted, @updated updated, @failed failed. Check details below.</div>
                            </div>
                        </div>
                        <div class="mt-4">
                            <div class="table-responsive" style="max-height: 220px; overflow:auto;">
                                <table class="table table-sm align-middle">
                                    <thead>
                                        <tr>
                                            <th>Student</th>
                                            <th>Course</th>
                                            <th>Status</th>
                                            <th>Message</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        @foreach (var row in results.Where(r => r.Status == ImportStatus.Failed))
                                        {
                                            <tr>
                                                <td>@row.StudentId</td>
                                                <td>@row.CourseId</td>
                                                <td><span class="badge bg-danger">Failed</span></td>
                                                <td>@row.Message</td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="inline-flex items-center gap-3 text-slate-700">
                            <i class="bi bi-x-circle-fill text-rose-500 text-2xl"></i>
                            <div>
                                <div class="text-lg font-semibold">Import failed</div>
                                <div class="text-sm text-slate-500">No rows were imported. See messages for details.</div>
                            </div>
                        </div>
                    }
                </div>
            }
</div>

@code {
    private IBrowserFile? file;
    private bool canProcess => file is not null;
    private bool isProcessing;
    private readonly List<ImportResult> results = new();

    private void OnFileChange(InputFileChangeEventArgs args)
    {
        file = args.File;
        results.Clear();
        
        Console.WriteLine($"[OnFileChange] File selected: {file?.Name ?? "NULL"}");
        
        // Show toast
        if (file != null)
        {
            Toasts.Enqueue($"File selected: {file.Name} ({file.Size} bytes)", FinalAssignemnt_APDP.Services.ToastType.Info);
            Console.WriteLine($"[OnFileChange] Toast enqueued for file: {file.Name}");
        }
        
        StateHasChanged(); // Force UI update
    }

    private async Task ProcessFile()
    {
        Console.WriteLine("[ProcessFile] === START ===");
        
        if (file is null)
        {
            Console.WriteLine("[ProcessFile] ERROR: No file selected");
            Toasts.Enqueue("No file selected", FinalAssignemnt_APDP.Services.ToastType.Warning);
            return;
        }

        if (isProcessing)
        {
            Console.WriteLine("[ProcessFile] ERROR: Already processing");
            return;
        }

        isProcessing = true;
        StateHasChanged(); // Update UI to show spinner
        
        string originalFileName = file.Name;
        Console.WriteLine($"[ProcessFile] File: {originalFileName}, Size: {file.Size} bytes");
        
        try
        {
            var extension = Path.GetExtension(file.Name).ToLowerInvariant();
            Console.WriteLine($"[ProcessFile] Extension: {extension}");

            // Use a single upload timestamp for all rows so we can update stored path later
            var uploadTimestamp = DateTime.UtcNow;

            if (extension == ".csv")
            {
                Toasts.Enqueue($"Processing CSV file...", FinalAssignemnt_APDP.Services.ToastType.Info);
                await ProcessCsvFile(originalFileName, uploadTimestamp);
            }
            else if (extension == ".xlsx" || extension == ".xls")
            {
                Toasts.Enqueue($"Processing Excel file...", FinalAssignemnt_APDP.Services.ToastType.Info);
                await ProcessExcelFile(originalFileName, uploadTimestamp);
            }
            else
            {
                Console.WriteLine($"[ProcessFile] ERROR: Unsupported extension: {extension}");
                Toasts.Enqueue("Unsupported file format. Please upload a CSV or Excel (.xlsx) file.", FinalAssignemnt_APDP.Services.ToastType.Error);
                return;
            }

            var successCount = results.Count(r => r.Status == ImportStatus.Inserted || r.Status == ImportStatus.Updated);
            var failCount = results.Count(r => r.Status == ImportStatus.Failed);
            
            Console.WriteLine($"[ProcessFile] Import complete: {successCount} successful, {failCount} failed, {results.Count} total");
            
            // Save file to uploads/grades if import was successful
            if (successCount > 0)
            {
                await SaveUploadedFile(originalFileName, uploadTimestamp);
                Toasts.Enqueue($"Import finished: {successCount} rows processed successfully", FinalAssignemnt_APDP.Services.ToastType.Success);
            }
            
            if (failCount > 0)
            {
                Toasts.Enqueue($"Warning: {failCount} rows failed", FinalAssignemnt_APDP.Services.ToastType.Warning);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ProcessFile] === EXCEPTION ===");
            Console.WriteLine($"[ProcessFile] Type: {ex.GetType().Name}");
            Console.WriteLine($"[ProcessFile] Message: {ex.Message}");
            Console.WriteLine($"[ProcessFile] StackTrace: {ex.StackTrace}");
            
            Toasts.Enqueue($"Import failed: {ex.Message}", FinalAssignemnt_APDP.Services.ToastType.Error);
        }
        finally
        {
            isProcessing = false;
            StateHasChanged(); // Update UI to hide spinner
            Console.WriteLine("[ProcessFile] === END ===");
        }
    }

    private async Task ProcessCsvFile(string originalFileName, DateTime uploadTimestamp)
    {
        Console.WriteLine("[ProcessCsvFile] Starting CSV processing");
        
        using var context = await DbFactory.CreateDbContextAsync();
        using var stream = file!.OpenReadStream(1_000_000);
        using var reader = new StreamReader(stream, Encoding.UTF8);
        
        var lineNumber = 0;
        
        // ? FIX: Use async pattern instead of EndOfStream
        string? line;
        while ((line = await reader.ReadLineAsync()) != null)
        {
            lineNumber++;
            
            if (string.IsNullOrWhiteSpace(line))
            {
                Console.WriteLine($"[ProcessCsvFile] Line {lineNumber}: Empty, skipping");
                continue;
            }
            
            if (lineNumber == 1 && line.StartsWith("StudentId", StringComparison.OrdinalIgnoreCase))
            {
                Console.WriteLine($"[ProcessCsvFile] Line {lineNumber}: Header row, skipping");
                continue;
            }

            Console.WriteLine($"[ProcessCsvFile] Line {lineNumber}: {line}");
            // Notify that the line is being read (lightweight progress)
            Toasts.Enqueue($"Reading line {lineNumber}", FinalAssignemnt_APDP.Services.ToastType.Info);
            var cells = line.Split(',');
            await ProcessRow(context, cells, lineNumber, originalFileName, uploadTimestamp);
        }
        
        Console.WriteLine($"[ProcessCsvFile] Finished processing {lineNumber} lines");
    }

    private async Task ProcessExcelFile(string originalFileName, DateTime uploadTimestamp)
    {
        Console.WriteLine("[ProcessExcelFile] Starting Excel processing");
        
        using var context = await DbFactory.CreateDbContextAsync();
        using var stream = file!.OpenReadStream(5_000_000);
        // EPPlus performs synchronous reads; BrowserFileStream doesn't support them.
        // Copy the browser stream into a MemoryStream asynchronously and pass that to EPPlus.
        await using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        ms.Position = 0;
        // Ensure EPPlus license context is set (required by newer EPPlus versions)
        ExcelPackage.LicenseContext = LicenseContext.NonCommercial;
        using var package = new ExcelPackage(ms);
        
        var worksheet = package.Workbook.Worksheets.FirstOrDefault();
        if (worksheet == null)
        {
            Console.WriteLine("[ProcessExcelFile] ERROR: No worksheet found");
            Toasts.Enqueue("No worksheet found in Excel file", FinalAssignemnt_APDP.Services.ToastType.Error);
            return;
        }

        var rowCount = worksheet.Dimension?.Rows ?? 0;
        Console.WriteLine($"[ProcessExcelFile] Found {rowCount} rows");
        
        if (rowCount == 0)
        {
            Console.WriteLine("[ProcessExcelFile] ERROR: Empty worksheet");
            Toasts.Enqueue("Excel file is empty", FinalAssignemnt_APDP.Services.ToastType.Error);
            return;
        }

        // Skip header row (row 1)
        for (int row = 2; row <= rowCount; row++)
        {
            var cells = new string[7];
            for (int col = 1; col <= Math.Min(7, worksheet.Dimension?.Columns ?? 0); col++)
            {
                cells[col - 1] = worksheet.Cells[row, col].Text?.Trim() ?? string.Empty;
            }
            
            Console.WriteLine($"[ProcessExcelFile] Row {row}: {string.Join(",", cells.Take(4))}");
            // Lightweight progress notification per row
            Toasts.Enqueue($"Reading row {row}", FinalAssignemnt_APDP.Services.ToastType.Info);
            await ProcessRow(context, cells, row, originalFileName, uploadTimestamp);
        }
        
        Console.WriteLine($"[ProcessExcelFile] Finished processing {rowCount - 1} data rows");
    }

    private async Task ProcessRow(ApplicationDbContext context, string[] cells, int rowNumber, string originalFileName, DateTime? uploadTimestamp = null)
    {
        var studentId = cells.ElementAtOrDefault(0)?.Trim() ?? string.Empty;
        var courseCell = cells.ElementAtOrDefault(1)?.Trim() ?? string.Empty;
        
        Console.WriteLine($"[ProcessRow] Row {rowNumber}: StudentId={studentId}, CourseId={courseCell}");
        
        if (cells.Length < 4)
        {
            var error = $"Row {rowNumber}: Expected at least 4 columns, got {cells.Length}";
            Console.WriteLine($"[ProcessRow] ERROR: {error}");
            results.Add(new ImportResult(studentId, courseCell, ImportStatus.Failed, error));
            Toasts.Enqueue(error, FinalAssignemnt_APDP.Services.ToastType.Error);
            return;
        }

        int courseId;
        // Try parse as numeric CourseId first
        if (!int.TryParse(courseCell, out courseId))
        {
            // If not numeric, try to find course by name (case-insensitive)
            var courseNameLookup = courseCell?.Trim() ?? string.Empty;
            Console.WriteLine($"[ProcessRow] Row {rowNumber}: Course lookup by name '{courseNameLookup}'");
            var lookupLower = courseNameLookup.ToLowerInvariant();
            var courseEntity = await context.Courses.FirstOrDefaultAsync(c => c.Name != null && c.Name.ToLower() == lookupLower);
            if (courseEntity == null)
            {
                var error = $"Row {rowNumber}: Course '{courseCell}' not found in database";
                Console.WriteLine($"[ProcessRow] ERROR: {error}");
                results.Add(new ImportResult(studentId, courseCell, ImportStatus.Failed, error));
                Toasts.Enqueue(error, FinalAssignemnt_APDP.Services.ToastType.Error);
                return;
            }

            courseId = courseEntity.Id;
            Console.WriteLine($"[ProcessRow] Row {rowNumber}: Resolved course name '{courseNameLookup}' to CourseID={courseId}");
        }
        
        double? midterm = TryParseDouble(cells.ElementAtOrDefault(2));
        double? final = TryParseDouble(cells.ElementAtOrDefault(3));
        var note = cells.ElementAtOrDefault(6)?.Trim();
        
        Console.WriteLine($"[ProcessRow] Row {rowNumber}: Midterm={midterm}, Final={final}");

        try
        {
            // Find user by StudentId property
            var user = await context.Users.FirstOrDefaultAsync(u => u.StudentId == studentId);
            if (user == null)
            {
                var error = $"Row {rowNumber}: Student '{studentId}' not found in database";
                Console.WriteLine($"[ProcessRow] ERROR: {error}");
                results.Add(new ImportResult(studentId, courseCell, ImportStatus.Failed, error));
                return;
            }

            Console.WriteLine($"[ProcessRow] Row {rowNumber}: Found user {user.Name} (Id: {user.Id})");

            // Check if grade already exists
            var entity = await context.Grades
                .FirstOrDefaultAsync(g => g.StudentID == user.Id && g.CourseID == courseId);
            
            var isNew = entity is null;
            
            if (isNew)
            {
                Console.WriteLine($"[ProcessRow] Row {rowNumber}: Creating new grade record");
                entity = new Grade { StudentID = user.Id, CourseID = courseId };
                context.Grades.Add(entity);
            }
            else
            {
                Console.WriteLine($"[ProcessRow] Row {rowNumber}: Updating existing grade record (Id: {entity.Id})");
            }
            
            // Update scores
            entity!.MidtermScore = midterm;
            entity.FinalScore = final;
            entity.Note = note;
            
            // Save file metadata
            entity.UploadedFileName = originalFileName;
            var ts = uploadTimestamp ?? DateTime.UtcNow;
            entity.UploadedFileDate = ts;
            
            // Calculate grade
            entity.CalculateGrade();
            
            Console.WriteLine($"[ProcessRow] Row {rowNumber}: Calculated Average={entity.AverageScore}, Letter={entity.LetterGrade}");
            
            // Save to database
            await context.SaveChangesAsync();
            
            Console.WriteLine($"[ProcessRow] Row {rowNumber}: ? Saved to database");
            // Notify success for this row (inserted or updated)
            Toasts.Enqueue($"Row {rowNumber}: {(isNew ? "Inserted" : "Updated")} - {studentId}/{courseId}", FinalAssignemnt_APDP.Services.ToastType.Success);

            results.Add(new ImportResult(
                studentId, 
                courseCell, 
                isNew ? ImportStatus.Inserted : ImportStatus.Updated, 
                "OK"
            ));
        }
        catch (Exception ex)
        {
            var error = $"Row {rowNumber}: {ex.Message}";
            Console.WriteLine($"[ProcessRow] ERROR: {error}");
            Console.WriteLine($"[ProcessRow] Exception: {ex.GetType().Name}");
            Console.WriteLine($"[ProcessRow] StackTrace: {ex.StackTrace}");
            
            results.Add(new ImportResult(studentId, courseCell, ImportStatus.Failed, error));
            Toasts.Enqueue(error, FinalAssignemnt_APDP.Services.ToastType.Error);
        }
    }

    private static double? TryParseDouble(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return null;
            
        if (double.TryParse(value, out var result))
        {
            return result;
        }
        return null;
    }

    private async Task DownloadExport()
    {
        try
        {
            // Try to read antiforgery token from a meta tag and use the enhanced download helper
            var token = await JSRuntime.InvokeAsync<string>("getCsrfTokenFromMeta", "RequestVerificationToken");
            await JSRuntime.InvokeVoidAsync("downloadFile", "/api/grades/export", new { csrfToken = token, csrfHeaderName = "RequestVerificationToken" });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DownloadExport] Error: {ex.Message}");
            Toasts.Enqueue("Failed to download export file", FinalAssignemnt_APDP.Services.ToastType.Error);
        }
    }

    private async Task SaveUploadedFile(string originalFileName, DateTime uploadTimestamp)
    {
        try
        {
            Console.WriteLine("[SaveUploadedFile] Saving file to uploads/grades...");
            
            // Create unique filename with timestamp
            var timestamp = DateTime.UtcNow.ToString("yyyyMMddHHmmss");
            var extension = Path.GetExtension(originalFileName);
            var fileNameWithoutExt = Path.GetFileNameWithoutExtension(originalFileName);
            var newFileName = $"{fileNameWithoutExt}_{timestamp}{extension}";
            
            // Get the uploads/grades directory path
            var uploadsPath = Path.Combine(WebHostEnvironment.WebRootPath, "uploads", "grades");
            
            // Ensure directory exists
            if (!Directory.Exists(uploadsPath))
            {
                Directory.CreateDirectory(uploadsPath);
                Console.WriteLine($"[SaveUploadedFile] Created directory: {uploadsPath}");
            }
            
            var filePath = Path.Combine(uploadsPath, newFileName);

            // Reset file stream and save
            using var fileStream = file!.OpenReadStream(5_000_000);
            using var fs = new FileStream(filePath, FileMode.Create);
            await fileStream.CopyToAsync(fs);

            var relativePath = $"/uploads/grades/{newFileName}";
            Console.WriteLine($"[SaveUploadedFile] âœ“ File saved: {newFileName}");
            Console.WriteLine($"[SaveUploadedFile] Path: {filePath}");

            // Remove previous stored file (if any) to avoid orphaned files
            try
            {
                await using var ctxForPrevious = await DbFactory.CreateDbContextAsync();
                var previousPath = await ctxForPrevious.Grades
                    .Where(g => !string.IsNullOrEmpty(g.UploadedFileStoredPath))
                    .OrderByDescending(g => g.UploadedFileDate)
                    .Select(g => g.UploadedFileStoredPath)
                    .FirstOrDefaultAsync();

                if (!string.IsNullOrEmpty(previousPath) && !string.Equals(previousPath, relativePath, StringComparison.OrdinalIgnoreCase))
                {
                    var deleted = FileUploadService.DeleteFile(previousPath);
                    Console.WriteLine($"[SaveUploadedFile] Deleted previous file: {previousPath} -> {deleted}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SaveUploadedFile] Warning deleting previous file: {ex.Message}");
            }

            // Update DB rows that were processed in this import to store the path
            try
            {
                using var ctx = await DbFactory.CreateDbContextAsync();
                var rowsToUpdate = await ctx.Grades.ToListAsync();

                foreach (var g in rowsToUpdate)
                {
                    g.UploadedFileName = originalFileName;
                    g.UploadedFileStoredPath = relativePath;
                    g.UploadedFileDate = uploadTimestamp;
                }

                if (rowsToUpdate.Count > 0)
                {
                    await ctx.SaveChangesAsync();
                    Console.WriteLine($"[SaveUploadedFile] Updated {rowsToUpdate.Count} grade rows with stored path and metadata.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SaveUploadedFile] ERROR updating DB rows: {ex.Message}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SaveUploadedFile] ERROR: {ex.Message}");
            Console.WriteLine($"[SaveUploadedFile] StackTrace: {ex.StackTrace}");
            // Don't throw - just log the error, import was already successful
        }
    }

    private sealed record ImportResult(string StudentId, string CourseId, ImportStatus Status, string Message);

    private enum ImportStatus
    {
        Inserted,
        Updated,
        Failed
    }
}
